## Введение {#toc-introduction}

В этой статье я научу вас, как загружать и исполнять JavaScript внутри браузера.

Нет-нет, погодите, вернитесь! Я знаю, что это звучит очень бонально и просто, но
помните, что все это происходит внутри браузера, где теоретически простые вещи
становятся воронкой, полной неочевидного поведения, причиной которому огромное
количество кода для обратной совместимости. Если вы знаете эти неочевидные
особенности поведения браузеров, то сможете выбрать самый быстрый и меньше всего
мешающий вам способ загружать скрипты. Если вы торопитесь, сразу открывайте [быструю справку][1].

Для начала, вот как [в спецификации][2] определяются различные способы, которыми
можно скачать и исполнить код:

![][3]
__WHATWG о загрузке скриптов__

Как и все спецификации WHATWG, с первого взгляда она больше всего напоминает
последствия попадания кластерной бомбы в фабрику по производству игры «Эрудит»,
но когда вы прочитали ее в пятый раз и вытерли кровь с глаз, все становится на
самом деле довольно интересно:

## Как я подключал скрипт в первый раз {#toc-first-script}

    <script src="//other-domain.com/1.js"></script>
    <script src="2.js"></script>

О святая простота! Итак, здесь браузер скачает оба скрипта параллельно и исполнит
их как можно быстрее, сохранив при этом их порядок. "2.js" не станет исполняться,
пока не выполнится (или не выдаст ошибку) "1.js". "1.js" не начнет исполняться,
пока не будет выполнен предыдущий скрипт (или не обработана таблица стилей) — и т.д.

К сожалению, пока все это происходит, браузер блокирует дальнейший рендеринг
страницы. Происходит это из-за доставшихся нам из «первой эпохи веба» DOM API,
которые позволяют прибавлять данные к содержимому, которое в настоящий момент
прожевывает браузер: такие, например, API, как `document.write`. Современные
браузеры будут продолжать сканировать и парсить документ в фоновом режиме, а
также начинать загрузку внешнего содержимого, которое требуется документу
(JS, CSS, изображения и т.п.), но рендеринг все равно будет блокирован.

Именно по этой причине лучшие специалисты по производительности советуют ставить
элементы `script` в самом конце документа: в таком случае выполнение скрипта
блокирует как можно меньше контента. К сожалению, это означает, что браузер не
увидит ваш скрипт до тех пор, пока не скачает весь HTML, а к этому моменту он
уже начал загружать остальной контент: CSS, изображения, iframe'ы. Современные
браузеры достаточно умные и дают JavaScript-файлам приоритет над картинками, но
можно сделать и лучше.

## Спасибо, IE! (и никакого сарказма) {#toc-thanks-ie}

    <script src="//other-domain.com/1.js" defer></script>
    <script src="2.js" defer></script>

Microsoft обратила внимание на эти проблемы с производительностью — и в Internet
Explorer 4 был введен атрибут `defer`. Означает он более-менее следующее:
«я обещаю не вставлять палки в колеса парсеру и не буду использовать такие вещи,
как `document.write`. Если я нарушу это обещание, можете наказывать меня как
хотите». Этот атрибут вошел [в спецификацию HTML4][4] и появился в других браузерах.

В примере наверху случится следующее: браузер скачает оба скрипта параллельно и
выполнит их прямо перед тем, как сработает событие `DOMContentLoaded` — в
правильном порядке.

"defer", как взорвавшаяся кластерная бомба на фабрике по производству шерсти, с
тал жутко запутанным клубком. Итого с атрибутами "src" и "defer", тэгами `script`
и динамически добавляемыми скриптами, всего у нас получилось шесть способов
добавить скрипт в документ. И, разумеется, разработчики браузеров не смогли
договориться о том, в каком порядке они должны исполняться.
[На сайте Mozilla есть отличная статья с описанием проблемы][5], как она
выглядела в 2009 году.

WHATWG стандартизировала поведение, объявив, что “defer” не должен иметь никакого
эффекта на динамически добавленные скрипты или скрипты без `src`. В остальных
случаях скрипты должны выполняться после того, как закончился парсинг документа,
в том порядке, в котором они были добавлены.

### Спасибо, IE! (окей, теперь это сарказм)

Бог дал, Бог взял. К сожалению, в IE4-9 есть очень противный баг, который может
[заставлять скрипты выполняться в неожиданном порядке][6]. Вот что происходит:

#### 1.js

    console.log('1');
    document.getElementsByTagName('p')[0].innerHTML = 'Изменяем какой-нибудь контент';
    console.log('2');


#### 2.js

    console.log('3');

Если на странице присутствует абзац, то мы ожидаем, что порядок записей в лог
будет идти как: [1, 2, 3], а в IE9 и ниже получается: [1, 3, 2]. Некоторые
операции с DOM заставляют IE приостановить выполнение текущего скрипта и
исполнить другие ожидающие выполнения скрипты перед тем, как продолжить.

Даже и в реализациях без багов (в IE10 и других браузерах) выполнение скрипта
будет отложено до того момента, как браузер скачает и распарсит весь документ.
Это не так и плохо, если вы в любом случае собираетесь ждать `DOMContentLoaded`,
но если вы хотите действительно агрессивно подойти к производительности, то
обработчики событий и подготовку кода можно начинать и раньше.

## HTML5 спешит на помощь {#toc-html5-rescue}

    <script src="//other-domain.com/1.js" async></script>
    <script src="2.js" async></script>

В HTML5 появился новый атрибут: “async”, он предполагает, что вы не будете
использовать `document.write`, но при этом браузер не будет ждать, пока документ
полностью распарсится, перед тем, как начать выполнение этого скрипта. Браузер
скачает оба скрипта параллельно и выполнит их как только сможет.

К сожалению, в силу того факта, что скрипты будут загружаться насколько возможно
быстро, может выйти так, что "2.js" загрузится перед "1.js". С этим нет проблем,
если они независимы друг от друга (например, "1.js" — скрипт аналитики и не имеет
ничего общего с "2.js"). Но если "1.js" — это CDN-копия jQuery, от которой
зависит "2.js", тогда ваша страница покроется ошибками, как взорвавшаяся
кластерная бомба в… в… ой, не знаю, не придумать метафоры.

## Я знаю, что спасет нас! JavaScript-библиотека! {#toc-js-lib}

Идеальная ситуация выглядела бы так: у нас был бы набор скриптов, которые
загружаются немедленно, не блокируют рендеринг и выполняются как только возможно
в том порядке, в котором они были добавлены. К сожалению, HTML ненавидит вас и
не даст вам так сделать.

Эту проблему пытались несколько раз решить на JavaScript. Одни решения
предлагали вам внести изменения в ваш JavaScript-код, обернув его в колбэк,
который библиотека вызовет в правильном порядке (например, [RequireJS][7]).
Другие используют XHR для параллельной загрузки, а потом исполняют через `eval()`
в правильном порядке, но это не работает для скриптов на других доменах, если
у них нет [CORS-заголовка][8] (а у браузера есть соответствующая поддержка).
Некоторые, как покойный LabJS, вообще использовали супер-магические хаки.

Хаки эти выглядели так: заставить браузер скачать ресурс так, что по окончании
загрузки будет вызвано событие — но при этом не исполнять ресурс. В LabJS скрипт
добавлялся с неправильным MIME-типом, например:
`<script type="script/cache" src="...">`. После того, как все скрипты скачались,
они добавлялись снова, уже с правильным типом, в надежде, что браузер загрузит
их из кэша и исполнит сразу и по порядку. Это опиралось на распространенное,
но не соответствующее спецификации поведение — и все сломалось, когда в HTML5
было объявлено, что браузеры не должны загружать скрипты с неизвестным типом.

У обоих этих приемов есть свои проблемы с производительностью. Нужно ждать, пока
загрузится и исполнится JavaScript-код библиотеки перед тем, как хоть какой-то
из тех скриптов, который ею управляется, начнет загружаться. Кроме того, как мы
собираемся загружать загрузчик скрипта? Как мы будем загружать скрипт, который
говорит загрузчику скриптов, что ему загружать? Кто следит за Хранителями?
Почему я голый? Это все очень сложные вопросы.

## DOM спешит на помощь {#toc-dom-rescue}

На самом деле ответ находится внутри спецификации HTML5, хотя от спрятан в самом
низу секции по загрузке скриптов.

> Атрибут async контролирует, будет ли элемент исполняться асинхронно. Если на
элементе установлен флаг "force-async", то при чтении атрибут async должен
возвращать "true". При записи флаг "force-async" должен быть снят…

Давайте переведем это на человеческий язык:

    [
      '//other-domain.com/1.js',
      '2.js'
    ].forEach(function(src) {
      var script = document.createElement('script');
      script.src = src;
      document.head.appendChild(script);
    });


**Скрипты, которые создаются и добавляются к документу динамически, асинхронны
по умолчанию**, не блокируют рендеринг и выполняются, как только загружены — 
но это значит, что они могут выполниться в неправильном порядке. Однако мы можем
эксплицитно пометить их как неасинхронные:

    [
      '//other-domain.com/1.js',
      '2.js'
    ].forEach(function(src) {
      var script = document.createElement('script');
      script.src = src;
      script.async = false;
      document.head.appendChild(script);
    });

Это дает нашим скриптам поведение, которого нельзя добиться только HTML. Скрипты
*эксплицитно* неасинхронны, они добавляются в очередь выполнения (та же самая
очередь, в которую они добавляются в нашем первом примере, где был только HTML).
Однако из-за того, что они создаются динамически, они выполняются независимо от
парсинга документа, так что рендеринг не блокируется, пока они загружаются (не
путайте неасинхронную загрузку скриптов с синхронным XHR, в котором нет ничего
хорошего).

Приведенный скрипт нужно включать прямо в заголовке страницы, чтобы загрузка
скриптов начиналась как можно быстрее, не мешая прогрессивному рендерингу, и в
ыполнялась как можно быстрее в том порядке, который вы установили. "2.js" легко
может скачаться перед "1.js", но он не будет загружен, пока "1.js" не скачался
и не выполнился (или произошла какая-то ошибка на том или другом этапе). Ура!
Асинхронная загрузка и исполнение по порядку!

Загружать скрипты таким образом можно
[во всех браузерах, которые поддерживают атрибут async][9], за исключением Safari
5.0 (в 5.1 все окей). Кроме того, этот метод поддерживают все версии Firefox и
Opera, поскольку те версии, которые не поддерживают атрибут async, все равно
исполняют динамически добавленные скрипты в том порядке, в котором они добавлены
в документ.

## Это же самый быстрый способ загружать скрипты, правда? ПРАВДА? {#toc-js-has-problems}

Ну, если вы динамически решаете, какие скрипты загружать, тогда да, в противном
случае, пожалуй, нет. С примером выше браузер должен распарсить и выполнить
скрипт для того, чтобы определить, какие скрипты скачивать. Это значит, что
ваши скрипты остаются скрытыми от сканеров предзагрузки. Браузеры используют эти
сканеры для того, чтобы найти на странице те ресурсы, которые браузеру, скорее
всего, скоро понадобятся — или найти ресурсы страницы, пока браузер блокирован
загрузкой другого ресурса.

Можно добавить видимость этих скриптов для браузера, поставив в заголовке
документа:

    <link rel="subresource" href="//other-domain.com/1.js">
    <link rel="subresource" href="2.js">

Эти директивы говорят браузеру, что странице нужны 1.js и 2.js, и они видны
модулю предзагрузки. `link[rel=subresource]` очень похож на `link[rel=prefetch]`,
но у него [другая семантика][10]. К сожалению, сейчас он поддерживается только в
Chrome, и вам нужно дважды декларировать, какие скрипты загружать: один раз в
ссылках, один раз в вашем скрипте.

## От этой статьи у меня развивается депрессия. {#toc-depressing}

Действительно, все это депрессивно, и то, что у вас депрессия, это нормально.
Нет способа — без повторов кода и декларативного — быстро и асинхронно загрузить
скрипты, контролируя при этом порядок их выполнения.

С HTTP2/SPDY можно уменьшить оверхед на запросы до такой степени, что самым
быстрым способом загружать JavaScript может быть передача скриптов отдельными
маленькими файлами (каждый из которых может индивидуально кэшироваться).
Представьте:

    <script src="dependencies.js"></script>
    <script src="enhancement-1.js"></script>
    <script src="enhancement-2.js"></script>
    <script src="enhancement-3.js"></script>
    …
    <script src="enhancement-10.js"></script>

Каждый скрипт улучшения работает с конкретным компонентом на странице, но ему
требуются сервисные функции из dependencies.js. В идеале мы бы все скачали
асинхронно, затем как можно быстрее загрузили бы скрипты улучшения, в любом
порядке, но после dependencies.js. Прогрессивное прогрессивное улучшение!

К сожалению, никакого декларативного способа добиться этого нет, если только
сами скрипты будут отслеживать состояние загрузки dependencies.js. Даже
`async=false` не решает эту проблему, поскольку выполнение enhancement-10.js
будет блокироваться, пока не выполнятся 1-9. На самом деле есть только один
браузер, в котором это возможно делать без хаков.

## У IE есть идея! {#toc-interesting-ie}

IE загружает скрипты не так, как другие браузеры.

    var script = document.createElement('script');
    script.src = 'whatever.js';

IE начинает скачивать “whatever.js” сразу, а другие браузеры не начинают
скачивать файл, пока скрипт не добавлен к доменту. У IE также есть событие
“readystatechange” и свойство “readystate”, которые позволяют нам следить за
процессом загрузки. Это на самом деле довольно полезно, поскольку позволяет нам
независимо контролировать загрузку и исполнение скриптов.

    var script = document.createElement('script');

    script.onreadystatechange = function() {
      if (script.readyState == 'loaded') {
        // Наш скрипт загрузился, но не исполнился.
        // И не исполнится, пока мы не скажем ему:
        document.body.appendChild(script);
      }
    };

    script.src = 'whatever.js';

Выбирая, когда добавить скрипты к документу, можно строить достаточно сложные
модели зависимости. IE поддерживает эту модель начиная с версии 6. Это довольно
интересно, но здесь есть та же проблема, что и с `async=false` — эти скрипты не
видны для модуля предзагрузки.

## Хватит! Скажите уже, как мне загружать скрипты! {#toc-enough}

Ладно-ладно. Итак, если вы хотите загружать скрипты так, чтобы это не
блокировало рендеринг, не заставляло бы вас писать повторяющийся код, и иметь
отличную браузерную поддержку, то вот что я предлагаю:

    <script src="//other-domain.com/1.js"></script>
    <script src="2.js"></script>

Вот это. В конце элемента `body`. Да, бытие веб-разработчика чем-то похоже на
бытие Сизифа (бум! +100 очков в хипстерству за ссылку на греческую мифологию).
Ограничения в HTML и браузерах не дают нам сделать что-то сильно лучше.

Я очень надеюсь, что [JavaScript-модули][11] спасут нас, предоставив
декларативный и неблокирующий способ загружать скрипты с сохранением контроля
над порядком их исполнения — хотя для этого придется писать скрипты как модули.

## Ммм, то есть ничего лучше сейчас нет, да? {#toc-aggressive-optimisation}

Ну на самом деле, если вы хотите заработать бонусные очки и агрессивно улучшить
производительность, а некоторая сложность и повторяемость вас не смущают, можно
совместить кое-что из приемов выше.

Во-первых, мы добавляем определения subresource, для тех браузеров, которые
занимаются предзагрузкой:

    <link rel="subresource" href="//other-domain.com/1.js">
    <link rel="subresource" href="2.js">

После этого сразу в заголовке документы мы загружаем наши скрипты через
JavaScript с помощью `async=false`, с фолбэком на загрузку скриптов через
IE-событие readystate, ну а если и это не работает, то с фолбэком на defer.

    var scripts = [
      '1.js',
      '2.js'
    ];
    var src;
    var script;
    var pendingScripts = [];
    var firstScript = document.scripts[0];

    // наблюдаем за тем, как IE загружает скрипты.
    function stateChange() {
      // выполняем по порядку столько скриптов, сколько можем.
      var pendingScript;
      while (pendingScripts[0] && pendingScripts[0].readyState == 'loaded') {
        pendingScript = pendingScripts.shift();
        // больше не будем загружать события от этого скрипта (например, если меняется src)
        pendingScript.onreadystatechange = null;
        // нельзя просто выполнить appendChild — старый баг в IE, если элемент не закрыт.
        firstScript.parentNode.insertBefore(pendingScript, firstScript);
      }
    }

    // проходимся через наши ссылки на скрипты
    while (src = scripts.shift()) {
      if ('async' in firstScript) { // современные браузеры
        script = document.createElement('script');
        script.async = false;
        script.src = src;
        document.head.appendChild(script);
      }
      else if (firstScript.readyState) { // IE<10
        // создаем скрипт и добавляем его в наш список
        script = document.createElement('script');
        pendingScripts.push(script);
        // смотрим за изменением состояния
        script.onreadystatechange = stateChange;
        // устанавливать src нужно только после того, как добавляем обработчик на onreadystatechange
        // иначе не поймаем событие загрузки для закэшированных скриптов
        script.src = src;
      }
      else { // ничего не получилось, пишем код через defer
        document.write('<script src="' + src + '" defer></'+'script>');
      }
    }

Пара оптимизаций, минификация — и: 362 байта + ссылки на ваши скрипты:

    !function(e,t,r){function n(){for(;d[0]&&"loaded"==d[0][f];)c=d.shift(),c[o]=!i.parentNode.insertBefore(c,i)}for(var s,a,c,d=[],i=e.scripts[0],o="onreadystatechange",f="readyState";s=r.shift();)a=e.createElement(t),"async"in i?(a.async=!1,e.head.appendChild(a)):i[f]?(d.push(a),a[o]=n):e.write("<"+t+' src="'+s+'" defer></'+t+">"),a.src=s}(document,"script",[
      "//other-domain.com/1.js",
      "2.js"
    ])

Стоит ли все это лишних байтов по сравнению с обычным включением скрипта.
Если вы уже используете JavaScript для условной загрузки скриптов ([как BBC][12]),
то начать их загрузку раньше выглядит вполне оправданным. В остальных случаях — 
наверное, нет, просто помещайте скрипты в конец `body`.

Уууф, теперь я понимаю, почему секция спецификации WHATWG по загрузке скриптов
была такой огромной. Пойду стопаря накачу.

## Быстрая справка {#toc-quick-reference}

### Простые элементы script

    <script src="//other-domain.com/1.js"></script>
    <script src="2.js"></script>


**Спецификация:** Скачивать вместе, выполнять по порядку после загрузки CSS,
блокировать рендеринг до завершения.

**Браузеры:** Да, сэр!

### Defer

    <script src="//other-domain.com/1.js" defer></script>
    <script src="2.js" defer></script>


**Спецификация:** Скачивать вместе, выполнять по порядку непосредственно перед
событием DOMContentLoaded. Игнорировать “defer” для скриптов, у которых нет “src”.

**IE < 10:** Ну, может быть, я выполню 2.js где-то посерединке исполнения 1.js.
Это же забавно, согласитесь?

**[Браузеры в красном][13]:** Понятия не имею, что это за “defer”, буду
выполнять скрипты так, как если бы его не было.

**Другие браузеры:** Окей, но я могу и не игнорировать “defer” на скриптах, у
которых нет “src”.

### Async

    <script src="//other-domain.com/1.js" async></script>
    <script src="2.js" async></script>


**Спецификация:** Скачивать вместе, выполнять в том порядкею, в котором они
будут загружены.

**[Браузеры в красном][9]:** Что это за ‘async’? Буду загружать скрипты, как
если бы его не было.

**Остальные браузеры:** О, оукей.

### Async false

    [
      '1.js',
      '2.js'
    ].forEach(function(src) {
      var script = document.createElement('script');
      script.src = src;
      script.async = false;
      document.head.appendChild(script);
    });


**Спецификация:** Скачивать вместе, выполнять по порядку тогда, когда все
загрузятся.

**Firefox < 3.6, Opera:** Понятия не имею, что это за “async”, но так уж вышло,
что  выполняю скрипты, которые добавляются через JS, в том порядке, в котором
они были добавлены.

**Safari 5.0:** Так, я знаю, что такое “async”, но не понимаю, как можно
устанавливать его значение в “false” через JS. Знаете что? Я выполню ваши
скрипты в таком порядке, в котором они загрузятся, а там уж как пойдет.

**IE < 10:** Ничего не знаю про “async”, но [меня можно убедить с помощью][14]
“onreadystatechange”.

**[Остальные браузеры в красном][9]:** Понятия не имею, что это за “async”. Буду
исполнять ваши скрипты по мере их поступления, в том порядке, в котором они
загрузятся.

**Все остальные:** Я ваш друг, сделаем все по инструкции!


 [1]: #toc-quick-reference
 [2]: http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script
 [3]: img/script-loading.png
 [4]: http://www.w3.org/TR/html401/interact/scripts.html#h-18.2.1
 [5]: https://hacks.mozilla.org/2009/06/defer/
 [6]: https://github.com/h5bp/lazyweb-requests/issues/42
 [7]: http://requirejs.org/
 [8]: https://developer.mozilla.org/en-US/docs/HTTP/Access_control_CORS
 [9]: http://caniuse.com/#search=async
 [10]: http://www.chromium.org/spdy/link-headers-and-server-hint/link-rel-subresource
 [11]: http://wiki.ecmascript.org/doku.php?id=harmony:modules
 [12]: http://responsivenews.co.uk/post/18948466399/cutting-the-mustard
 [13]: http://caniuse.com/#search=defer
 [14]: #interesting-ie